(1) What was the problem you were solving in the projects for this course?

The main problem I worked on was developing an efficient program to organize, sort, and display course information for a university’s Computer Science program. The program needed to load data from a file, store it in different data structures, and allow users to search or print the course list. The goal was to evaluate which data structure (vector, hash table, or binary search tree) offered the best balance of performance and simplicity for this purpose.

(2) How did you approach the problem?

I started by analyzing the requirements for each project and deciding which data structure made the most sense to use in each context. I implemented all three data structures to better understand their trade-offs. The vector version was straightforward and easy to implement but slow for searching. The binary search tree offered faster lookups and sorted output but was more complex to manage. The hash table provided the fastest average lookup and insertion times, which made it the best choice for retrieving course information efficiently.

(3) How did you overcome any roadblocks you encountered while going through the activities or project?

One of the main challenges was debugging issues with file input and ensuring the data was parsed correctly into each structure. I also ran into logic errors when printing course details or sorting lists in the correct order. I overcame these issues through step-by-step testing, verifying that the file loaded properly before adding new logic, and by printing intermediate outputs to confirm that each step worked as expected. Writing pseudocode first helped clarify my logic before translating it into C++ code.

(4) How has your work on this project expanded your approach to designing software and developing programs?

This project taught me how important it is to select the right data structure for the job. I learned to analyze how runtime and memory usage affect a program’s efficiency and scalability. I also gained more experience structuring code into clear, reusable components, which made the overall program easier to read, maintain, and debug. Beyond coding, I learned to think critically about algorithmic performance and how theoretical complexity translates into real-world execution.

(5) How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

I now focus more on clarity, modular design, and documentation. Adding meaningful comments and structuring code logically made it much easier to revisit and update my work later. Through this course, I also realized how valuable reflection and version control are. Using GitHub allowed me to track progress and make changes safely. Moving forward, I will continue organizing my projects with clear functions, consistent naming conventions, and concise documentation to ensure that my programs remain easy to maintain and scale.
